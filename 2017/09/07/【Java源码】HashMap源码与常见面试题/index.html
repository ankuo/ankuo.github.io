<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>【Java源码】HashMap源码与常见面试题 | 岸阔</title><meta name="description" content="【Java源码】HashMap源码与常见面试题"><meta name="keywords" content="源码"><meta name="author" content="ankuo"><meta name="copyright" content="ankuo"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2017/09/07/【Java源码】HashMap源码与常见面试题/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="【Java源码】HashMap源码与常见面试题"><meta name="twitter:description" content="【Java源码】HashMap源码与常见面试题"><meta name="twitter:image" content="http://yoursite.com/img/avatar.png"><meta property="og:type" content="article"><meta property="og:title" content="【Java源码】HashMap源码与常见面试题"><meta property="og:url" content="http://yoursite.com/2017/09/07/【Java源码】HashMap源码与常见面试题/"><meta property="og:site_name" content="岸阔"><meta property="og:description" content="【Java源码】HashMap源码与常见面试题"><meta property="og:image" content="http://yoursite.com/img/avatar.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'true', 'auto');
ga('send', 'pageview');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight_copy: 'true',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days'

  
}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程安全的-Map-（concurrentHashMap）"><span class="toc-number">1.</span> <span class="toc-text">#线程安全的 Map （concurrentHashMap）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet和TreeSet有什么区别"><span class="toc-number">2.</span> <span class="toc-text">#HashSet和TreeSet有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap的实现原理理"><span class="toc-number">3.</span> <span class="toc-text">#LinkedHashMap的实现原理理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什什么集合类没有实现Cloneable和Serializable接⼝口"><span class="toc-number">4.</span> <span class="toc-text">#为什什么集合类没有实现Cloneable和Serializable接⼝口?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是迭代器（Iterator）"><span class="toc-number">5.</span> <span class="toc-text">#什么是迭代器（Iterator）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator和ListIterator的区别是什什么"><span class="toc-number">6.</span> <span class="toc-text">#Iterator和ListIterator的区别是什什么?</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#源码分析"><span class="toc-number"></span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#成员变量"><span class="toc-number">1.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造方法"><span class="toc-number">2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内部类"><span class="toc-number">3.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主要方法"><span class="toc-number">4.</span> <span class="toc-text">主要方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#put-方法"><span class="toc-number">4.1.</span> <span class="toc-text">put 方法</span></a></li></ol></li></ol></li></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/post.png)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">岸阔</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><div class="menu_mask"></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item text-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">1</div></a></div></div><div class="mobile_data_item text-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">1</div></a></div></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">【Java源码】HashMap源码与常见面试题</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-07</time></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>java集合框架</p>
<p>#常见面试题</p>
<p>##HashMap实现原理</p>
<pre><code>map是以健值对来存储对象的，其底层实际上是数组和链表和红黑树来组成的。当使用put方法时，先找出数组位置是否存在对象，通过key.hashcode数组长度取余；存在，则把里面的链表拿出来，判断链表里面是否存在key值与传递过来的key值一样的对象，存在，则把传递过来的value取代链表key对应的value,不存在，则直接通过链表的add()方法加。

当使用get方法时，先查找出数组位置是否存在对象，通过key.hashcode对数组长度取余；如果不存在，则返回为空，如果存在，则遍历链表，判断链表里面是否存在key值与传递过来的key值一样的对象，存在，则把key值对应的value取出返回,不存在，则返回为空；</code></pre><blockquote>
<p>特性</p>
</blockquote>
<ul>
<li>容量（capacity）</li>
<li>负载因子(load factor)</li>
<li>扩容极限(threshold resizing)</li>
</ul>
<p>hashMap<strong>初始容量为16</strong>，当hashmap中的元素个数<strong>超过数组大小*负载因子</strong>时，就会发生数组扩容resize，</p>
<p><strong>负载因子(load factor)默认为0.75</strong>，）也就是那么当hashmap中的元素个数超过16*0.75=12时，就把数组大小扩展为2X16=32，即扩大一倍，然后重新计算每个元素的个数在数组中的位置，这是一个非常耗时的操作，所以我们最好在new hashmap时设置其初始化大小。比如我们有1000个元素需要写成new hashMap（1000），但是理论上讲1024更合适，不过即使我们填写1000底层也会将其设置为1024。但是1024也不一定能够满足我们，因为0.75X1000 &lt; 1000。也就是为来让0.75Xsize &gt; 1000，我们必须设置为2048才最合适，这样既考虑了&amp;的问题，也避免了resiz的问题。</p>
<blockquote>
<p>注意：</p>
<p>负载因子</p>
<p>没有特定需求不必去改变这个数字，因为当负载因子较大时，去给table数组扩容的可能性就会少，所以相对占用内存较少（空间上较少），但是每条entry链上的元素会相对较多，查询的时间也会增长（时间上较多）。反之就是，负载因子较少的时候，给table数组扩容的可能性就高，那么内存空间占用就多，但是entry链上的元素就会相对较少，查出的时间也会减少。所以才有了负载因子是时间和空间上的一种折中的说法。所以设置负载因子的时候要考虑自己追求的是时间还是空间上的少。</p>
<p>扩容极限</p>
<p>为2^ 31</p>
</blockquote>
<h2 id="线程安全的-Map-（concurrentHashMap）"><a href="#线程安全的-Map-（concurrentHashMap）" class="headerlink" title="#线程安全的 Map （concurrentHashMap）"></a><strong>#线程安全的 Map （concurrentHashMap</strong>）</h2><p>jdk1.7中采用 Segment + HashEntry的方式进行实现。segment数组的意义就是将一个大的table分割成多个小的table进行加锁，而每一个segment元素存储的是HashEntry数组加链表，这个和HashMap的数据存储结构一样。</p>
<p>而jdk1.8中则</p>
<p>去除 Segment + HashEntry + Unsafe 的实现，</p>
<p>改为 Synchronized + CAS + Node + Unsafe 的实现</p>
<p>取消了Segment字段，数组中存储的就是Node。它与HashMap中的HashEntry定义很相似，但是有一些差别。它对value和next属性设置了volatile同步锁，它不允许调用setValue方法直接改变Node的value域。</p>
<p>另外，将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构，在hash碰撞过多的情况下会将链表转化成红黑树。</p>
<h2 id="HashSet和TreeSet有什么区别"><a href="#HashSet和TreeSet有什么区别" class="headerlink" title="#HashSet和TreeSet有什么区别"></a>#HashSet和TreeSet有什么区别</h2><blockquote>
<p>HashSet是由⼀一个hash表来实现的，因此，它的元素是⽆无序的。add()，remove()，contains()</p>
<p>TreeSet是由⼀一个树形的结构来实现的，它⾥里里⾯面的元素是有序的。因此，add()， remove()，contains()⽅方法的时间复杂度是O(logn)。</p>
</blockquote>
<h2 id="LinkedHashMap的实现原理理"><a href="#LinkedHashMap的实现原理理" class="headerlink" title="#LinkedHashMap的实现原理理"></a><strong>#LinkedHashMap</strong>的实现原理理</h2><blockquote>
<p><strong>LinkedHashMap</strong>是基于HashMap实现的，不同的是它定义了一个Entry header ，这个header不是放在Table里，他是额外独立出来的，LingkedHashMap继承HashMap中的Entry，并添加两个属性Entry before after 和header结合起来组成一个双向链表，来实现按插入顺序或访问书序拍排序。LinkedHashMap定义了了排序模式accessOrder，该属性为boolean型变 量量，对于访问顺序，为true;对于插⼊入顺序，则为false。⼀一般情况下，不不必指定排序模式，其 迭代顺序即为默认为插⼊入顺序。</p>
</blockquote>
<h2 id="为什什么集合类没有实现Cloneable和Serializable接⼝口"><a href="#为什什么集合类没有实现Cloneable和Serializable接⼝口" class="headerlink" title="#为什什么集合类没有实现Cloneable和Serializable接⼝口?"></a>#为什什么集合类没有实现<strong>Cloneable</strong>和<strong>Serializable</strong>接⼝口?</h2><blockquote>
<p>克隆隆(cloning)或者是序列列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该 由</p>
<p>集合类的具体实现来决定如何被克隆隆或者是序列列化。</p>
</blockquote>
<h2 id="什么是迭代器（Iterator）"><a href="#什么是迭代器（Iterator）" class="headerlink" title="#什么是迭代器（Iterator）"></a>#什么是迭代器（Iterator）</h2><blockquote>
<p>Iterator接⼝口提供了了很多对集合元素进⾏行行迭代的⽅方法。每⼀一个集合类都包含了了可以返回迭代 器器实 例例的迭代⽅方法。迭代器器可以在迭代的过程中删除底层集合的元素,但是不不可以直接调⽤用集合的remove(Object Obj)删除，可以通过迭代器器的remove()⽅方法删除。</p>
</blockquote>
<h2 id="Iterator和ListIterator的区别是什什么"><a href="#Iterator和ListIterator的区别是什什么" class="headerlink" title="#Iterator和ListIterator的区别是什什么?"></a><strong>#Iterator</strong>和<strong>ListIterator</strong>的区别是什什么?</h2><blockquote>
<p>下⾯面列列出了了他们的区别:</p>
<p>Iterator可⽤用来遍历Set和List集合，但是ListIterator只能⽤用来遍历List。</p>
<p>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</p>
<p>ListIterator实现了了Iterator接⼝口，并包含其他的功能，⽐比如:增加元素，替换元素，获取前⼀一个 和后⼀一个元素的索引，等等。</p>
</blockquote>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>jdk1.8</p>
<p>HashMap位于java.util包下继承AbstractMap实现了Map，Cloneable，Serializable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>先接受其所用到的成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认初始化大小为2^4=16 必须是2的幂</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大的容量为 2^30  必须是2的幂</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 负载因子0.75</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当一个数组上的链表的长度大于8则转化为红黑树，降低遍历效率</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当一个数组的下的数量小于6时 会由红黑树转化成链表</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当整个HashMap中的数量大于64时也会使用红黑书</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容量乘以装在因子所得结果，如果key-value的 数量等于该值，则调用resize方法，扩大容量，同时修改threshold的值</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造方法将使用默认的加载因子（0.75）初始化。		</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 			<span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以设置初始大小的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 可以指定 初始大小和加载因子的方法。tableSizeFor（）方法会严格要求把初始化的容量是以2的次方数成长只				能是16、32、64、128...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                             initialCapacity);</span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">          initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">      <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">      <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">      <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 按照之前的hashMap的对象，重新深拷贝一份HashMap对象，使用的加载因子是默认的加载因子：0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">      putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap中将我们存入的每一个数据封装成一个Node类（Node节点），Node有key和value组成我们的键值对，既然要组织起链表必须有Nodel next属性，还有一个根据key算出来的int类型hash值。</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><blockquote>
<p>执行逻辑</p>
</blockquote>
<p>1.根据key计算当前Node的hash值来判断该node位于HashMap的数组中的那个位置</p>
<p>2.判断table有没有初始化，没有则调用resize方法初始化容量和threshold</p>
<p>3.如果当前hash值的索引处没有node 则调用newNode方法为其创建一个node</p>
<p>4.如果hash值定位的索引有node，并且node中的key和新增的key一致，则准备更新value；如果当前位置是红黑树，则更新红黑树中的值</p>
<p>5.如果hash值定位的索引有node但是key不一致，则遍历的将node添加到末尾（如果链表的长度大于8则调用treeifyBin（）方法扩大table数组的容量，如果大于threshold的值，则调用resize（）方法，扩大当前HashMap对象的存储容量）</p>
<p>6.返回oldValue或者null</p>
<p>put 方法比较经常使用的方法，主要功能是为HashMap对象添加一个Node 节点，如果Node存在则更新Node里面的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// put 的方法主要的实现逻辑在 putVal中，这个方法也被最后一个构造方法调用了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key的hash值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> onlyIfAbsent如果是true，则不修改已存在的value值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> evict if false, 表示是在初始化时调用的.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 返回被修改的value，或者返回null。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">      <span class="comment">// 如果是第一次调用，则会触发 resize（）方法 初始化 table 和 threshold</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">          n = (tab = resize()).length;</span><br><span class="line">      <span class="comment">// 如果对应的索引没有Node 则新建Node放到table中</span></span><br><span class="line">      <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">          tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          Node&lt;K,V&gt; e; K k;</span><br><span class="line">          <span class="comment">// 如果hash值与已经存在的hash相等，并且key也相等，则准备更新对应Node的value</span></span><br><span class="line">          <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">              ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              e = p;</span><br><span class="line">        	<span class="comment">// 若是红黑树 则更新红黑树的值</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">              e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果hash值一致，但是key不一致，那么将新的key-value添加到已有的Node的最后面</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                  <span class="comment">// 遍历到尾部，追加新节点到尾部</span></span><br><span class="line">                  <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                      <span class="comment">// 如果追加节点后，链表数量》=8，则转化为红黑树</span></span><br><span class="line">                      <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                          treeifyBin(tab, hash);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 如果找到了要覆盖的节点 </span></span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  p = e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        	<span class="comment">// 如果e不是null，说明有需要覆盖的节点</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            	<span class="comment">// 则覆盖节点值，并返回原oldValue</span></span><br><span class="line">              V oldValue = e.value;</span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                  e.value = value;</span><br><span class="line">            	<span class="comment">// 这是一个空实现的函数，用作LinkedHashMap重写使用。</span></span><br><span class="line">              afterNodeAccess(e);</span><br><span class="line">              <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    	<span class="comment">// 如果执行到了这里，说明插入了一个新的节点，所以会修改modCount，以及返回null</span></span><br><span class="line">      ++modCount;</span><br><span class="line">    	<span class="comment">// 更新size，并判断是否需要扩容</span></span><br><span class="line">      <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">          resize();</span><br><span class="line">    	<span class="comment">// 这是一个空实现的函数，用作LinkedHashMap重写使用</span></span><br><span class="line">      afterNodeInsertion(evict);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">ankuo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2017/09/07/【Java源码】HashMap源码与常见面试题/">http://yoursite.com/2017/09/07/【Java源码】HashMap源码与常见面试题/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/源码/">源码    </a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://yoursite.com/2017/09/07/【Java源码】HashMap源码与常见面试题/';
  this.page.identifier = '2017/09/07/【Java源码】HashMap源码与常见面试题/';
  this.page.title = '【Java源码】HashMap源码与常见面试题';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;1927 - 2019 By ankuo</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://ankuo.github.io">blog</a>!</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><a id="to_comment" href="#post-comment"><i class="scroll_to_comment fa fa-comments"></i></a><i class="fa fa-book" id="readmode" title="Read Mode"> </i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><i class="fa fa-moon-o nightshift" id="nightshift" title="Dark Mode"></i></section><div id="post_bottom"><div id="post_bottom_items"><a id="mobile_to_comment" href="#post-comment"><i class="mobile_scroll_to_comment fa fa-comments"></i></a><i class="fa fa-list" id="mobile_toc"></i><div id="toc_mobile"><div class="toc_mobile_headline">Catalog</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#线程安全的-Map-（concurrentHashMap）"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">#线程安全的 Map （concurrentHashMap）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#HashSet和TreeSet有什么区别"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">#HashSet和TreeSet有什么区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#LinkedHashMap的实现原理理"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">#LinkedHashMap的实现原理理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#为什什么集合类没有实现Cloneable和Serializable接⼝口"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">#为什什么集合类没有实现Cloneable和Serializable接⼝口?</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#什么是迭代器（Iterator）"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">#什么是迭代器（Iterator）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Iterator和ListIterator的区别是什什么"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">#Iterator和ListIterator的区别是什什么?</span></a></li></ol><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#源码分析"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">源码分析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#成员变量"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">成员变量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#构造方法"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">构造方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#内部类"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">内部类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#主要方法"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">主要方法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#put-方法"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">put 方法</span></a></li></ol></li></ol></li></div></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zindex="-1" data-click="false"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPoss":0.5,"vHeadPos":0.5,"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"superSample":2,"width":200,"height":420,"position":"left","hOffset":0,"vOffset":-20},"log":false});</script></body></html>