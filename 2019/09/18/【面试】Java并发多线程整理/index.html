<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>【面试】Java并发多线程整理 | 岸阔</title><meta name="description" content="【面试】Java并发多线程整理"><meta name="keywords" content="面试,并发"><meta name="author" content="ankuo"><meta name="copyright" content="ankuo"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/09/18/【面试】Java并发多线程整理/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="【面试】Java并发多线程整理"><meta name="twitter:description" content="【面试】Java并发多线程整理"><meta name="twitter:image" content="https://s2.ax1x.com/2019/09/18/nHxqjU.jpg"><meta property="og:type" content="article"><meta property="og:title" content="【面试】Java并发多线程整理"><meta property="og:url" content="http://yoursite.com/2019/09/18/【面试】Java并发多线程整理/"><meta property="og:site_name" content="岸阔"><meta property="og:description" content="【面试】Java并发多线程整理"><meta property="og:image" content="https://s2.ax1x.com/2019/09/18/nHxqjU.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="next" title="【面试】接口抽象类和设计模式整理" href="http://yoursite.com/2017/09/16/【面试】接口抽象类和设计模式整理/"><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'true', 'auto');
ga('send', 'pageview');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight_copy: 'true',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days'

  
}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized和ReentrantLock有什么区别"><span class="toc-number">1.</span> <span class="toc-text">synchronized和ReentrantLock有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized底层是如何实现的-什么是锁的降级和升级"><span class="toc-number">2.</span> <span class="toc-text">synchronized底层是如何实现的,什么是锁的降级和升级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他锁"><span class="toc-number">3.</span> <span class="toc-text">其他锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么需要有读写锁-ReadWriteLock"><span class="toc-number">4.</span> <span class="toc-text">为什么需要有读写锁(ReadWriteLock)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自旋锁"><span class="toc-number">5.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一个线程两次调用-start-会怎么样"><span class="toc-number">6.</span> <span class="toc-text">一个线程两次调用 start()会怎么样</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的基本概念"><span class="toc-number">7.</span> <span class="toc-text">线程的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁"><span class="toc-number">8.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java并发包提供了那些并发工具类"><span class="toc-number">9.</span> <span class="toc-text">Java并发包提供了那些并发工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">9.1.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">9.2.</span> <span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore"><span class="toc-number">9.3.</span> <span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">9.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发包里提供的线程安全Map、List和Set"><span class="toc-number">10.</span> <span class="toc-text">并发包里提供的线程安全Map、List和Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别"><span class="toc-number">11.</span> <span class="toc-text">并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别?</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/09/18/nHxqjU.jpg)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">岸阔</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><div class="menu_mask"></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item text-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">7</div></a></div></div><div class="mobile_data_item text-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">3</div></a></div></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">【面试】Java并发多线程整理</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2019-09-18<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> Updated 2019-09-25</time></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="synchronized和ReentrantLock有什么区别"><a href="#synchronized和ReentrantLock有什么区别" class="headerlink" title="synchronized和ReentrantLock有什么区别"></a>synchronized和ReentrantLock有什么区别</h2><p>synchronized是java内建的同步机制，所以也有人称其为Intrinsic Locking ，它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在哪里。</p>
<p>java5之前，synchronized是仅有的同步手段，在代码中，synchronized可以用来修饰方法，也可以使用在特定的代码块上，本质synchronized方法等同于把方法全部语句用synchronized包起来</p>
<p>ReentrantLock 通常翻译为再入锁，是java5提供的锁的实现，它的语义和synchronized基本相同。再入锁通过代码直接调用lock()方法获取，代码书写也更加灵活。与此同 时，ReentrantLock提供了很多实用的方法，能够实现很多synchronized无法做到的细节控制，比如可以控制<strong>fairness</strong>，也就是公平性，或者利用定义条件等。但是，编码中也需 要注意，<strong>必须要明确调用</strong>unlock()方法释放，不然就会一直持有该锁。</p>
<p>synchronized和ReentrantLock的性能不能一概而论，早期版本synchronized在很多场景下性能相差较大，在后续版本进行了较多改进，在低竞争场景中表现可能优于ReentrantLock。</p>
<blockquote>
<p>锁时并发的基础工具之一，至少掌握</p>
</blockquote>
<ul>
<li>理解什么是线程安全</li>
<li>synchronized和ReentrantLock等机制基本使用和案例</li>
<li>掌握synchronized和ReentrantLock底层实现；理解锁膨胀，降级；理解偏斜锁、自旋锁、轻量级锁、重量级锁</li>
</ul>
<blockquote>
<p>保证线程安全的两个方法</p>
</blockquote>
<ul>
<li>封装</li>
<li>不可变</li>
</ul>
<blockquote>
<p>线程安全的基本特性</p>
</blockquote>
<ul>
<li>原子性：相关操作不会中途被其他线程干扰，一般通过同步机制实现</li>
<li>可见性：一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的</li>
<li>有序性：是保证线程内串行语义，避免指令重排等</li>
</ul>
<blockquote>
<p>ReentrantLock 使用</p>
</blockquote>
<p>当一个线程试图获取一个它已经获取的锁时，这个锁获取动作就自动成功了，这是对锁获取的一个概念，也就是锁的持有是以线程为单位的而不是基于调用次数。Java锁实现再入性是为了和pthread的行为进行区分</p>
<p>再入锁可以设置公平性(fairness)，我们可在创建再入锁时选择是否是公平的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 当公平性为真时，会倾向于将锁赋予等待时间最久的线程。公平性减少线程饥饿（个别线程长期等待锁，但始终无法获取）情况发生的一个办法</span></span><br><span class="line"><span class="comment"> 如果使用synchronized 我们根本无法进行公平性的选择，其永远是不公平的，这也是主流操作系统线程调度的选择。</span></span><br><span class="line"><span class="comment"> 公平性未必有想象中的那么重要，Java默认的调 度策略很少会导致 “饥饿”发生。与此同时，若要保证公平性则会引</span></span><br><span class="line"><span class="comment"> 入 额外开销，自然会导致一定的吞吐量下降。所以，我建议只有当你的程序确实有公平性需要的时候，才有必要指 定它。*/</span></span><br><span class="line">ReentrantLock fairLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>​        <strong>为保证锁释放，每一个lock()动作，我建议都立即对应一个try-catch-fnally</strong></p>
<blockquote>
<p>举例子 一个标准类库中的ArrayBlockingQueue</p>
</blockquote>
<p>通过再入锁获取条件变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">        notEmpty = lock.newCondition();</span><br><span class="line">        notFull =  lock.newCondition();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>两个条件变量是从同一再入锁创建出来,然后使用在特定操作中,如下的 take 方法,判断和等待条件满足</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            <span class="keyword">return</span> dequeue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当队列为空,试图 take 的线程的正确行为应该是等待入队的发生,而不是直接返回,这是 BlockingQueue 的语义,使用条件 notEmpty 就可以优雅地实现这一逻辑那么,怎么保证入队触发后续 take 操作呢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">        <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        items[putIndex] = x;</span><br><span class="line">        <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">            putIndex = <span class="number">0</span>;</span><br><span class="line">        count++;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过signal/await的组合，完成了条件判断和通知等待线程，非常顺畅就完成了状态流转.注意，signal和await成对调用非常重要，不然假设只有await动作，线程会一直等待直到被打断(interrupt)。</p>
<h2 id="synchronized底层是如何实现的-什么是锁的降级和升级"><a href="#synchronized底层是如何实现的-什么是锁的降级和升级" class="headerlink" title="synchronized底层是如何实现的,什么是锁的降级和升级"></a>synchronized底层是如何实现的,什么是锁的降级和升级</h2><p>synchronized代码块是由一对儿monitorenter/monitorexit指令实现的,Monitor对象是同步的基本实现单元.</p>
<p><strong>Java6 之前</strong>,Monitor的实现完全是依靠操作系统内部的互斥锁,因为需要进行用户态到内核态的切换,所以同步操作是一个无差别的重量级操作.</p>
<p><strong>现在 jdk 提供</strong>了三种不同的Monitor实现,也就是我们常说的三种不同的锁,偏斜锁(Biased Locking),轻量级锁,重量级锁.</p>
<p>所谓的锁升级,降级,就是 jvm 优化 synchronized 运行的机制,jvm 检测到不同的竞争状态时,会自动切换到适合的锁实现,这种切换就是锁的升级,降级</p>
<ul>
<li><p>当没有竞争出现</p>
<p>默认使用<strong>偏斜锁</strong>.</p>
<ol>
<li>Jvm 会利用 CAS 操作在对象头上的 Mark Word 部分设置线程 ID 以表示这个对象偏向于当前线程,所以并不干涉及真正的互斥锁.</li>
<li>因为大部分对象生命周期最多会被一个线程锁定,使用偏斜锁可以降低无竞争开销.</li>
<li>如果有另外的线程试图锁定某个已经被偏斜过的对象,JVM 就需要撤销(revoke)偏斜锁,并切换到轻量级锁实现,</li>
</ol>
</li>
<li><p>轻量级锁</p>
<p>轻量级依赖 CAS 操作Mark Word 来试图获取锁,如果重试成功,就使用普通的轻量级锁,否则,进一步升级为重量级锁</p>
</li>
<li><p>锁的降级</p>
<p>锁降级确实会发生,当 Jvm 进入安全点(safepoint)的时候,会检查是否有限制的Monitor,然后试图进行降级</p>
</li>
</ul>
<blockquote>
<p>synchronized代码实现</p>
</blockquote>
<p>synchronized是 jvm 内部的 Intrinsic Lock 所以偏斜锁,轻量锁,重量锁的实现不在核心类库里,在 JVN 代码中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Handle <span class="title">h_obj</span><span class="params">(THREAD, obj)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fas entry if bias is revoked to avoid unnecessary infation</span></span><br><span class="line">    ObjectSynchronizer::fas_enter(h_obj, lock, <span class="literal">true</span>, CHECK);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ObjectSynchronizer::slow_enter(h_obj, lock, CHECK); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UseBiasedLocking是一个检查,因为 JVM 启动时,我们可以指定是否开启偏向锁.</p>
<p>注意:偏斜锁并不适合所有应用场景，撤销操作(revoke)是比较重的行为，只有当存在较多不会真正竞争的synchronized块儿时，才能体现出明显改善。实践中对于偏斜锁的一直是有 争议的，有人甚至认为，当你需要大量使用并发类库时，往往意味着你不需要偏斜锁。从具体选择来看，我还是建议需要在实践中进行测试，根据结果再决定是否使用。</p>
<p>还有一方面是，偏斜锁会延缓JIT 预热的进程，所以很多性能测试中会显式地关闭偏斜锁，命令如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:-UseBiasedLocking</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>fas_enter是我们熟悉的完整锁获取路径,slow_enter则是绕过了偏斜锁,直接进入轻量级锁的逻辑.</p>
<p>那么fas_enter是如何实现的,同样是通过在代码库搜索,可以定位到synchronizer.cpp类似 fast_enter 这种实现,解释器或者动态编译器,都是拷贝这段基础逻辑</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectSynchronizer::fas_enter(Handle obj, BasicLock* lock, <span class="keyword">bool</span> attempt_rebias, TRAPS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!SafepointSynchronize::is_at_safepoint()) &#123;</span><br><span class="line">                BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD); </span><br><span class="line">                <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">                    <span class="keyword">return</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                assert(!attempt_rebias, <span class="string">"can not rebias toward VM thread"</span>); BiasedLocking::revoke_at_safepoint(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            assert(!obj-&gt;mark()-&gt;has_bias_pattern(), <span class="string">"biases should be revoked by now"</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        slow_enter(obj, lock, THREAD); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>一起来看下其逻辑:</p>
<ul>
<li>BiasedLocking定义了偏斜锁相关操作,revoke_and_rebias是获取偏斜锁的入口方法,revoke_at_safepoint则定义了当检测安全点的处理逻辑</li>
<li>如果获取偏斜锁失败,则进入 slow_enter</li>
<li>这个方法里面同样检查是否开启了偏斜锁,但是从代码路径看,如果关闭了偏斜锁,是不会进入这个方法的,所以算是个额外的保障性检查吧.</li>
</ul>
<p>BiasedLocking是通过 CAS 设置 Mark Word的</p>
<blockquote>
<p>偏斜锁到轻量级锁的过程是如何实现的?</p>
</blockquote>
<p>slow_enter方法如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) &#123;</span><br><span class="line">    markOop mark = obj-&gt;mark();</span><br><span class="line">    <span class="keyword">if</span> (mark-&gt;is_neutral()) &#123;</span><br><span class="line">        <span class="comment">// 将目前的Mark Word复制到Displaced Header上</span></span><br><span class="line">        lock-&gt;set_displaced_header(mark);</span><br><span class="line">        <span class="comment">// 利用CAS设置对象的Mark Word</span></span><br><span class="line">        <span class="keyword">if</span> (mark == obj()-&gt;cas_set_mark((markOop) lock, mark)) &#123;</span><br><span class="line">            TEVENT(slow_enter: release sacklock);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 检查存在竞争</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mark-&gt;has_locker() &amp;&amp;</span><br><span class="line">            THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) &#123;</span><br><span class="line">        <span class="comment">// 清除</span></span><br><span class="line">        lock-&gt;set_displaced_header(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置Displaced Header </span></span><br><span class="line">    lock-&gt;set_displaced_header(markOopDesc::unused_mark()); </span><br><span class="line">    ObjectSynchronizer::infate(THREAD, obj(), infate_cause_monitor_enter)-&gt;enter(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置 Displaced Header,然后利用cas_set_mark设置对象 Mark Word 如果成就成功获取轻量级锁.</li>
<li>否则Displaced Header,然后进入锁膨胀阶段,具体实现在 inflate 方法中,</li>
<li>defate_idle_monitors是是分析锁降级逻辑的入口，这部分行为还在进行持续改进，因为其逻辑是在安全点内运行，处理不当可能拖长JVM停顿(STW，stop-the-world)的时 间。</li>
<li>fast_exit或者slow_exit是对应的锁释放逻辑。</li>
</ul>
<h2 id="其他锁"><a href="#其他锁" class="headerlink" title="其他锁"></a>其他锁</h2><p>除了synchronized和ReentrantLock,Java 核心类库中还有其他一些特别的锁类型</p>
<ul>
<li><p>ReadWriteLock是一个单独的接口</p>
<p>它通常是代表一对锁,分别对应只读和写操作,标准类库提供了再入版本的读写锁实现(ReentrantReadWriteLock),对应的语义和 ReentrantLock 比较相似</p>
</li>
<li><p>StampedLock 不支持再入性的语义,也就是它不是以持有锁的线程为单位,</p>
</li>
</ul>
<h2 id="为什么需要有读写锁-ReadWriteLock"><a href="#为什么需要有读写锁-ReadWriteLock" class="headerlink" title="为什么需要有读写锁(ReadWriteLock)"></a>为什么需要有读写锁(ReadWriteLock)</h2><p>虽然ReentrantLock和synchronized简单实用，但是行为上有一定局限性，通俗点说就是“太霸道”，要么不占，要么独占.有的时候不需要大量竞争 的写操作，而是以并发读取为主，如何进一步优化并发操作的粒度呢?</p>
<p>Java并发包提供的读写锁等扩展了锁的能力，它所基于的原理是<strong>多个读操作是不需要互斥的</strong>，因为读操作并不会更改数据，所以不存在互相干扰。而写操作则会导致并发一致性的问 题，</p>
<p>所以写线程之间、读写线程之间，需要精心设计的互斥逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RWSample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; m = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        System.out.println(<span class="string">"读锁锁定!"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">put</span><span class="params">(String key, String entry)</span> </span>&#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        System.out.println(<span class="string">"写锁锁定!"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m.put(key, entry);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行过程中,如果读锁试图锁定时,写锁是被某个线程持有,读锁无法获得,而只好等待对方操作结束,这样就可以自动保证不会读到有争议的数据.</p>
<p>读写锁看起来比synchronized的粒度似乎细一些，但在实际应用中，其表现也并不尽如人意，主要还是因为相对比较大的开销。</p>
<p>所以，JDK在后期引入了StampedLock，在提供类似读写锁的同时，还支持<strong>优化读模式</strong>。</p>
<p>优化读基于假设，大多数情况下读操作并不会和写操作冲突，其逻辑是先试着修改，</p>
<p>然后 通过validate方法确认是否进入了写模式，如果没有进入，</p>
<p>就成功避免了开销;如果进入，则尝试获取读锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedSample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mutate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> samp = sl.writeLock(); <span class="keyword">try</span> &#123;</span><br><span class="line">            write();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sl.unlockWrite(samp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Data <span class="title">access</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> samp = sl.tryOptimisicRead(); </span><br><span class="line">        Data data = read();</span><br><span class="line">        <span class="keyword">if</span> (!sl.validate(samp)) &#123;</span><br><span class="line">            samp = sl.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                data = read(); </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlockRead(samp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:这里的 writeLock 和 unLockWrite 一定要保证成对调用</p>
<p>不仅仅是各种Lock，其他的如Semaphore、CountDownLatch，甚至是早期的FutureTask 等，都是基于一</p>
<p>种<strong>AQS框架</strong>。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><ul>
<li>原理:</li>
</ul>
<p>竞争失败的线程,并不会真是的在操作系统层面挂起等待,而是 JVM 会让线程做几个空循环(基于预测在不久的将来就能获得),在经过若干次循环后,如果可以获得锁,那么进入临界区,如果还不能获得锁,才会真实的将线程在操作系统层面进行挂起</p>
<ul>
<li>适用场景:</li>
</ul>
<p>自旋锁可以<strong>减少线程的阻塞,</strong>这对于锁竞争不激烈,且<strong>占用锁时间非常短的代码</strong>块来说,有较大的性能提升,因为自旋锁的消耗会小于线程阻塞挂起操作的消耗.</p>
<p>如果锁竞争激烈,或者持有锁的线程需要长时间占用锁执行同步代码块,就不适合使用自旋锁了,因为自旋锁在获取锁前一直占用 cpu 做无用功,线程自旋的消耗大于线程阻塞挂起操作的消 耗，造成cpu的浪费。</p>
<ul>
<li>注意 :</li>
</ul>
<p>在单核CPU上，自旋锁是无用，因为当自旋锁尝试获取锁不成功会一直尝试，这会一直占用CPU，其他线程不可能运行，</p>
<p>同时由于其他线程无法运行，所以当前线程无法释放锁</p>
<blockquote>
<p>扩展</p>
</blockquote>
<p>混合型互斥锁， 在多核系统上起初表现的像自旋锁一样， 如果一个线程不能获取互斥锁， 它不会马上被切换为休眠状态，在一段时间依然无法获取锁，进行睡眠状态。 </p>
<p>混合型自旋锁，起初表现的和正常自旋锁一样，如果无法获取互斥锁，它也许会放弃该线程的执行，并允许其他线程执行。</p>
<p> 切记，自旋锁只有在多核CPU上有效果，单核毫无效果，只是浪费时间。</p>
<h2 id="一个线程两次调用-start-会怎么样"><a href="#一个线程两次调用-start-会怎么样" class="headerlink" title="一个线程两次调用 start()会怎么样"></a>一个线程两次调用 start()会怎么样</h2><p>Java的线程是不允许启动两次的，第二次调用必然会抛出IllegalThreadStateException，这是一种运行时异常，多次调用start被认为是编程错误</p>
<h2 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h2><blockquote>
<p>线程的生命周期</p>
</blockquote>
<ul>
<li><p>新建(new)</p>
<p>表示线程被创建出来还没真正启动的状态,可以认为它是个 java 内部的状态</p>
</li>
<li><p>就绪(Runable)</p>
<p>表示该线程已经在 jvm 中执行,当然由于执行需要计算资源,它可能是正在运行,也可能是还在等待系统分配给他 CPU 片段,在就绪队列</p>
</li>
<li><p>阻塞(Blocked)</p>
<p>阻塞表示线程在等待 Monitor lock.比如,线程试图通过 synchronize 去获取某个锁,但是其他线程已经独占了,那么当前线程就会处于阻塞状态.</p>
</li>
<li><p>等待(waiting)</p>
<p>表示正在等待其他线程采取某些操作.一个常见的场景是类似生产者消费者模式,发现任务条件尚未满足,就让当前消费者线程等待,另外的生产线程去准备任务数据,然后通过类型 notify 等动作,通知消费线程可以继续工作了.Thread.join()也会令线程进入的等待状态.</p>
<ul>
<li><p>计时等待(timed_wait)</p>
<p>和其他进入条件和等待状态类似,但是调用的是存在超时条件的方法,比如 wait 或 join 等方法的指定超时版本,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>终止(terminated)</p>
<p>不管是意外退出还是正常执行结束,线程已经完成使命,终止运行,也有人把这个状态叫死亡</p>
</li>
</ul>
<blockquote>
<p>线程是什么</p>
</blockquote>
<p>线程是系统调度的最小单元,一个进程可以包含多个线程,作为任务的真正执行者,有自己的栈寄存器,本地存储等,但是会和进程内其他线程共享文件描述符,虚拟地址空间等.现在的模型是一对一映射到操作系统内核线程.</p>
<p>如果我们来看Thread的源码，你会发现其基本操作逻辑大都是以JNI形式调用的本地代码。</p>
<blockquote>
<p>在 java 中哪些因素可能影响线程的状态呢?</p>
</blockquote>
<ul>
<li><p>join 等待线程结束;yield 是告诉调度器,主动让出 CPU;</p>
</li>
<li><p>如果我们持有某个对象的 Monitor 锁,调用 wait 会让当前线程处于等待状态,直到 其他线程 notify 或者notifyAll,</p>
</li>
<li><p>并发类库中的工具,比如 CountDownLatch.await”()会让当前线程进入等待状态,直到 latch 被计数为 0,这可以看做是线程间的通信的 signal</p>
</li>
</ul>
<blockquote>
<p>打印最简单的 Hello World ,java 会创建多少个线程</p>
</blockquote>
<p>JVM 启动 Hello World的线程分析<br>环境:<br>macOS + jdk8</p>
<p>检测获得</p>
<p>Thread[Reference Handler,10,system] </p>
<p>Thread[Finalizer,8,system] </p>
<p>Thread[main,5,main]</p>
<p>Thread[Signal Dispatcher,9,system] </p>
<p>Hello World!</p>
<p>其中:<br>Reference Handler:处理引用对象本身的垃圾回收</p>
<p>Finalizer:处理用户的Finalizer方法</p>
<p>Signal Dispatcher:外部jvm命令的转发器</p>
<p>在jdk6环境中</p>
<p>还有一个Attach Listener的线程 是负责接收外部命令的，如jmap、jstack</p>
<blockquote>
<p>为什么慎用 ThreadLocal</p>
</blockquote>
<p>theadlocal里面的值如果是线程池的线程里面设置的，当任务完成，线程归还线程池时，这个threadlocal里面的值不会被回收.</p>
<blockquote>
<p>使用多线程的一些建议</p>
</blockquote>
<p>线程的等待和唤醒，建议使用reentrantlock的condition wait/notify方法</p>
<ol start="2">
<li><p>可以使用线程的join方法、countdownlatch、cyclicbarrier、future等进行线程的等待</p>
</li>
<li><p>线程池一般不建议和thread local配合…</p>
</li>
</ol>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><blockquote>
<p>什么情况下会出现死锁</p>
</blockquote>
<ol>
<li>死锁是一种特定的程序状态,在实体之间,由于循环依赖导致彼此一直处于等待之中,没有任何个体可以继续前进.</li>
</ol>
<p>死锁不仅仅是在线程之间会发生,</p>
<ol start="2">
<li><p>存在资源独占的进程之间同样会出现.</p>
</li>
<li><p>类加载过程发生的死锁，尤其是在框架大量使用自定义类加载时，因为往往不是在应用本身的代码库</p>
<p>中，jstack等工具也不见得能够显示全部锁信息，所以处理起来比较棘手</p>
</li>
</ol>
<p>通常来说,我们大多是聚焦在多线程场景中的死锁,指两个或多个线程之间,由于互相持有对方需要的锁,而永久处于阻塞状态</p>
<blockquote>
<p>如何定位?修复?</p>
</blockquote>
<ol>
<li>定位死锁最常见的方式就是<strong>利用 jstack 等工具</strong>获取线程栈,</li>
<li>然后定位互相之间的依赖关系,进而找到死锁.</li>
<li>如果是比较明显的死锁,往往 jstack 就能之间定位,</li>
<li>像类似 jConsole 甚至可在人图形化进行有限的死锁检测</li>
</ol>
<p>如果程序运行过程中发生了死锁,绝大多数都是无法在线解决的,只能重启,修正程序本身问题,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ThreadMXBean mbean = ManagementFactory.getThreadMXBean();</span><br><span class="line">    Runnable dlCheck = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span>[] threadIds = mbean.findDeadlockedThreads();</span><br><span class="line">            <span class="keyword">if</span> (threadIds != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ThreadInfo[] threadInfos = mbean.getThreadInfo(threadIds);</span><br><span class="line">                System.out.println(<span class="string">"Detected deadlock threads:"</span>);</span><br><span class="line">                <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">                    System.out.println(threadInfo.getThreadName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">    scheduler.scheduleAtFixedRate(dlCheck, <span class="number">5L</span>, <span class="number">10L</span>, TimeUnit.SECONDS); <span class="comment">// 死锁样例代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如何在编程中尽量预防死锁呢</p>
</blockquote>
<p>可通过产生死锁的原因入手</p>
<ul>
<li>互斥条件,类似 Java 中Monitor 都是独占的,要么是我用,要么是你用</li>
<li>互斥条件是长期持有的, 在使用结束之前,自己不会释放,也不能被其他线程抢占.</li>
<li>循环依赖关系, 两个或者多个个体之间出现了锁的链条环.</li>
</ul>
<p>所以 我们可分析出避免死锁的思路和方法</p>
<p>一,尽量避免使用多个锁,并且只有需要时才持有锁.嵌套的synchronized或者lock非常容易出问题</p>
<p>二,如果必须使用多个锁,尽量设计好锁的获取顺序,可参考银行家算法</p>
<ul>
<li>将对象(方法)和锁之间的关系,用图像化的方式抽取出来,</li>
<li>然后根据对象之间组合,调用的关系对比和组合,考虑可能调用时序</li>
<li>按照可能时序合并,发现死锁的场景</li>
</ul>
<p>三,使用带有超时的方法,为程序带来更多可控性.类似Object.wait(…)或者CountDownLatch.await(…)，都支持所谓的timed_wait，我们完全可以就不假定该锁一定会获得，指定超时时间，并为无法得到锁时准备退出逻辑.</p>
<p>并发Lock实现，如ReentrantLock还支持非阻塞式的获取锁操作tryLock()，</p>
<p>这是一个插队行为(barging)，并不在乎等待的公平性，如果执行时对象恰好没有被独占，则直接获 取锁。</p>
<p>有时，我们希望条件允许就尝试插队，不然就按照现有公平性规则等待，一般采用下面的方法;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock() || lock.tryLock(timeout, unit)) &#123; <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四,可使用 sonar 或者阿里代码规约等插件来帮助检测是否有死锁发生的可能</p>
<blockquote>
<p>补充</p>
</blockquote>
<ol>
<li>死锁的另一个好朋友就是饥饿。死锁和饥饿都是线程活跃性问题。<br>实践中死锁可以使用 jvm 自带的工具进行排查。</li>
<li>死循环死锁可以认为是自旋锁死锁的一种，其他线程因为等待不到具体的信号提示。导致线程一直饥饿。 这种情况下可以查看线程 cpu 使用情况，排查出使用 cpu 时间片最高的线程，再打出该线程的堆栈信息，排查代码。</li>
<li>基于互斥量的锁如果发生死锁往往 cpu 使用率较低，实践中也可以从这一方面进行排查。</li>
</ol>
<h2 id="Java并发包提供了那些并发工具类"><a href="#Java并发包提供了那些并发工具类" class="headerlink" title="Java并发包提供了那些并发工具类"></a>Java并发包提供了那些并发工具类</h2><ul>
<li>提供 了比 synchronized 更加高级的各种同步结构,是CountDownLatch、Semaphore和CyclicBarrier</li>
</ul>
<p>可以实现更加丰富的线程操作,比如利用 semaphore 作为资源控制器,限制同时进行工作的线程的数量</p>
<ul>
<li>各种线程安全的容器,比如各种 BlockedQueue 实现,比较典型的 ArrayBlockedQueue,SynchorousQueue 或针对特定场景的 PriorityBlockingQueue 等</li>
<li>强大 的 Executor 框架,可以创建各种不同类型的线程池,调度运行任务等.</li>
</ul>
<blockquote>
<p>CountDownLatch、Semaphore和CyclicBarrier简单的区别</p>
</blockquote>
<ol>
<li><p>CountDownLatch 主要是实现了1个或N个线程需要等待其他线程完成某项操作之后才能继续往下执行操作，描述的是1个线程或N个线程等待其他线程的关系。</p>
</li>
<li><p>CyclicBarrier主要是实现了多个线程之间相互等待，直到所有的线程都满足了条件之后各自才能继续执行后续的操作，描述的多个线程内部相互等待的关系。</p>
</li>
<li><p>CountDownLatch是一次性的，而CyclicBarrier则可以被重置而重复使用。</p>
</li>
<li><p>Semaphore与CountDownLatch相似，不同的地方在于Semaphore的值被获取到后是可以释放的，并不像CountDownLatch那样一直减到底。它也被更多地用来<strong>限制流量</strong>，类似阀门的 功能。如果限定某些资源最多有N个线程可以访问，那么超过N个主不允许再有线程来访问，同时当现有线程结束后，就会释放，然后允许新的线程进来。</p>
</li>
</ol>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><blockquote>
<p>CountDownLatch简单使用过程与适合场景</p>
</blockquote>
<p>CountDownLatch是一个计数器闭锁，通过它可以完成类似于阻塞当前线程的功能，即：</p>
<p>一个线程或多个线程一直等待，直到其他线程执行的操作完成。</p>
<ol>
<li>CountDownLatch用一个给定的计数器来初始化，该计数器的操作是原子操作，即同时只能有一个线程去操作该计数器。</li>
<li>调用该类await方法的线程会一直处于阻塞状态，直到其他线程调用countDown方法使当前计数器的值变为零(每次调用countDown计数器的值减1)。</li>
<li>当计数器值减至零时，所有因调用await()方法而处于等待状态的线程就会继续往下执行。</li>
<li>这种现象只会出现一次，因为计数器不能被重置，如果业务上需要一个可以重置计数次数的版本，可以考虑使用CycliBarrier。</li>
</ol>
<p>在某些业务场景中，程序执行需要等待某个条件完成后才能继续执行后续的操作；典型的应用如并行计算，当某个处理的运算量很大时，可以将该运算任务拆分成多个子任务，等待所有的子任务都完成之后，父任务再拿到所有子任务的运算结果进行汇总。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    test1(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"finish"</span>);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"threadNum = "</span> + threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;:</span><br><span class="line">threadNum = <span class="number">0</span></span><br><span class="line">threadNum = <span class="number">3</span></span><br><span class="line">threadNum = <span class="number">4</span></span><br><span class="line">threadNum = <span class="number">2</span></span><br><span class="line">threadNum = <span class="number">1</span></span><br><span class="line">threadNum = <span class="number">6</span></span><br><span class="line">threadNum = <span class="number">9</span></span><br><span class="line">threadNum = <span class="number">7</span></span><br><span class="line">threadNum = <span class="number">8</span></span><br><span class="line">threadNum = <span class="number">5</span></span><br><span class="line">finish</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可设置超时时间 跳过等待</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    test1(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await(<span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        System.out.println(<span class="string">"finish"</span>);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"threadNum = "</span> + threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;:</span><br><span class="line">finish</span><br><span class="line">threadNum = <span class="number">0</span></span><br><span class="line">threadNum = <span class="number">1</span></span><br><span class="line">threadNum = <span class="number">2</span></span><br><span class="line">threadNum = <span class="number">3</span></span><br><span class="line">threadNum = <span class="number">4</span></span><br><span class="line">threadNum = <span class="number">7</span></span><br><span class="line">threadNum = <span class="number">6</span></span><br><span class="line">threadNum = <span class="number">9</span></span><br><span class="line">threadNum = <span class="number">5</span></span><br><span class="line">threadNum = <span class="number">8</span></span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><blockquote>
<p>CyclicBarrier简单使用过程,使用场景</p>
</blockquote>
<p>CyclicBarrier也是一个同步辅助类，它允许一组线程相互等待，直到到达某个公共屏障点（common barrier point）。通过它可以完成多个线程之间相互等待，只有当每个线程都准备就绪后，才能各自继续往下执行后面的操作。类似于CountDownLatch，它也是通过计数器来实现的。</p>
<ol>
<li>当某个线程调用await方法时，该线程进入等待状态，且计数器加1.</li>
<li>当计数器的值达到设置的初始值时，所有因调用await进入等待状态的线程被唤醒，继续执行后续操作。</li>
<li>因为CycliBarrier在释放等待线程后可以重用，所以称为循环barrier。</li>
<li>CycliBarrier支持一个可选的Runnable，在计数器的值到达设定值后（但在释放所有线程之前），该Runnable运行一次，注，Runnable在每个屏障点只运行一个。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    race(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">race</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(threadNum + <span class="string">" is ready"</span>);</span><br><span class="line">        barrier.await();</span><br><span class="line">        System.out.println(threadNum + <span class="string">" continue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;:</span><br><span class="line"><span class="number">0</span> is ready</span><br><span class="line"><span class="number">1</span> is ready</span><br><span class="line"><span class="number">2</span> is ready</span><br><span class="line"><span class="number">3</span> is ready</span><br><span class="line"><span class="number">4</span> is ready</span><br><span class="line"><span class="number">4</span> <span class="keyword">continue</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">continue</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">continue</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">continue</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">continue</span></span><br><span class="line"><span class="number">5</span> is ready</span><br><span class="line"><span class="number">6</span> is ready</span><br><span class="line"><span class="number">7</span> is ready</span><br><span class="line"><span class="number">8</span> is ready</span><br><span class="line"><span class="number">9</span> is ready</span><br><span class="line"><span class="number">9</span> <span class="keyword">continue</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">continue</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">continue</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">continue</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置超时时间的设置</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    race(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">race</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(threadNum + <span class="string">" is ready"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            barrier.await(<span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(threadNum + <span class="string">" continue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><blockquote>
<p>Semaphore简单使用,和场景</p>
</blockquote>
<p>Semaphore与CountDownLatch相似，不同的地方在于Semaphore的值被获取到后是可以释放的，并不像CountDownLatch那样一直减到底。它也被更多地用来<strong>限制流量</strong>，类似阀门的 功能。</p>
<ol>
<li>如果限定某些资源最多有N个线程可以访问，那么超过N个主不允许再有线程来访问，同时当现有线程结束后，就会释放.</li>
<li>然后允许新的线程进来。</li>
<li>有点类似于锁的lock与 unlock过程。相对来说他也有两个主要的方法：</li>
</ol>
<p>用于获取权限的acquire(),其底层实现与CountDownLatch.countdown()类似;<br>用于释放权限的release()，其底层实现与acquire()是一个互逆的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> thredNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    test(thredNum);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> thredNum)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"thredNum = "</span> + thredNum);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取多个许可</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> thredNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire(<span class="number">3</span>);</span><br><span class="line">                    test(thredNum);</span><br><span class="line">                    semaphore.release(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> thredNum)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"thredNum = "</span> + thredNum);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试获取许可 设置超时时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> thredNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (semaphore.tryAcquire(<span class="number">5000</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                        test(thredNum);</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> thredNum)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"thredNum = "</span> + thredNum);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，我们可以看出Semaphore就是个计数器，其基本逻辑基于acquire/release，并没有太复杂的同步逻辑。 如果Semaphore的数值被初始化为1，那么一个线程就可以通过acquire进入互斥状态，本质上和互斥锁是非常相似的。但是区别也非常明显，比如互斥锁是有持有者的，而对</p>
<p>于Semaphore这种计数器结构，虽然有类似功能，但其实不存在真正意义的持有者，除非我们进行扩展包装。</p>
<p>来看看CountDownLatch和CyclicBarrier，它们的行为有一定的相似度</p>
<ul>
<li>CountDownLatch 是不可以重置的,所以无法重用,而 CyclicBarrier 则没有这种限制,可以重用.</li>
<li>CountDownLatch 的基本操作组合是 countDown/await.调用 await 的线程阻塞等待 countDown足够的次数,不管你是一个线程还是多个线程里的 countDown,只要次数足够即可.<strong>CountDownLatch操作的是事件</strong></li>
<li>CycliBarrier 的基本操作组合,则就是 await,当所有伙伴(parties)都调用了 await,才会继续进行任务,并自动进行重置.注意,正常情况下,CycliBarrier 的重置都是自动发生的,如果我们调用了 reset 方法,但还有线程在等待,就会导致线程被打扰,抛出BrokenBarrierException异常。CyclicBarrier侧重点是线程，而不是调用事件.它的 <strong>典型应用场景是用来等待并发线程结束</strong>。</li>
</ul>
<h2 id="并发包里提供的线程安全Map、List和Set"><a href="#并发包里提供的线程安全Map、List和Set" class="headerlink" title="并发包里提供的线程安全Map、List和Set"></a>并发包里提供的线程安全Map、List和Set</h2><p>1.侧重于Map放入或者获取的速度，而不在乎顺序，大多推荐使用ConcurrentHashMap.</p>
<p>2.反之则使用ConcurrentSkipListMap,如果需要对大量数据进行非常频繁的修改,ConcurrentSkipListMap也可能表现出优势.</p>
<p>3.CopyOnWriteArraySet是通过包装了CopyOnWriteArrayList来实现的.CopyOnWrite的做 add,set,remove 都会拷贝原数组,修改后悔替换原来的数组,通过防御性的方式,实现另类的线程安全,所以这种适合读多写少的数据.</p>
<h2 id="并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别"><a href="#并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别" class="headerlink" title="并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别?"></a>并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别?</h2><ul>
<li><p>Concurrent类型基于 lock-free,在常见的多线程访问场景,一般可以提供较高吞吐量</p>
</li>
<li><p>而 LinkedBlockingQueue内部则是基于锁,并提供了 BlockingQueue的等待特性方法</p>
</li>
<li><p>Concurrent对修改没有较重的开销,低遍历一致性(其对应的就是 fast-fail,也就是检测容器遍历过程发生修改,就抛出异常,不再继续遍历),size 不准确,读取不一定准确</p>
</li>
</ul>
<blockquote>
<p>ConcurrentLinkedDeque和LinkedBlockingDeque</p>
</blockquote>
<p>Deque的侧重点事支持队列<strong>头尾都可进行插入和删除</strong></p>
<ul>
<li>尾部插入时 addLast(e),offerLast(e)</li>
<li>尾部删除时 remove(e),pollLast(e)</li>
</ul>
<blockquote>
<p>那些队列是有界的,那些是无届的</p>
</blockquote>
<ul>
<li><p>有界</p>
<p>ArrayBlockingQueue</p>
<p>LinkedBlockingQueue </p>
<p>SynchronousQueue</p>
</li>
<li><p>无届</p>
<p>PriorityBlockingQueue </p>
<p>DelayedQueue </p>
<p>LinkedTransferQueue </p>
</li>
</ul>
<blockquote>
<p>根据不同场景,如何选择</p>
</blockquote>
<ul>
<li><p>应用场景对边界有要求</p>
<p>ArrayBlockingQueue 是有明确的容量限制,而 LinkedBlockingQueue 取决于我们是否在创建时指定,SynchronousQueue 则干脆不能缓存任何元素.</p>
</li>
<li><p>空利用角度</p>
<p>数据结构的 ArrayBlockingQueue 要比 LinkedBlockingQueue紧凑,因为其不需要创建所谓节点,但是其初始化分配阶段就需要一段连续的空间,所以初始化内存需要大</p>
</li>
<li><p>通用场景</p>
<p>LinkedBlockingQueue 的吞吐量一般优于 ArrayBlockingQueue,因为它实现了更加细粒度的锁操作.</p>
<p>ArrayBlockingQueue实现简单,性能更好预测,表现稳定</p>
</li>
<li><p>线程之间接力</p>
<p>可能会选择 CountDownLatch,但是 SynchronousQueue 也是完美符合这种场景(在队列较小时表现超过其他)</p>
</li>
</ul>
<blockquote>
<p>从源码角度,常见的线程安全队列是如何实现的,并进行了那些改进以提高表现</p>
</blockquote>
<ol>
<li><p>BlockingQueue基本都是基于锁实现.</p>
</li>
<li><p>LinkedBlockingQueue则改进了锁操作的粒度，头、尾操作使用不同的锁，所以在通用场景下，它的吞吐量相对要更好 一些</p>
</li>
<li><p>ConcurrentLinkedQueue等，则是基于CAS的无锁技术，不需要在每个操作时使用锁，所以扩展性表现要更加优异</p>
</li>
<li><p>SynchronousQueue，在Java 6中，其实现发生了非常大的变化，利用CAS替换掉了原本基于锁的逻辑，同步开销比较小。它是Executors.newCachedThreadPool()的默认队列</p>
</li>
</ol>
<blockquote>
<p>补充:</p>
</blockquote>
<p>从行为特征上,  </p>
<p>BlockingQueue</p>
<p>1.绝大部分Queue 都实现了 BlockingQueue 接口.在常规队列操作基础上,Blocking 意味着为其提供了特定的等待性操作,获取是(take)等待元素进队,或者插入时(put)等待队列出现空位.</p>
<p>2.是否有界,</p>
<ul>
<li>ArrayBlockingQueue是最典型的有界队列,其内部以 final 的数组保存数据,数组的大小就决定来队列的边界,所以我们在创建ArrayBlockingQueue时,都要指定容量.</li>
<li>LinkedBlockingQueue 容易被误解为无边界,但其实其行为和内部代码都会基于有界的逻辑实现的,只不过我们如果没有指定容量,那么就容量限制会自动被设置为 Integer.MAX_VALUE,成为无届队列.</li>
<li>SynchronousQueue,每个删除操作都要等待插入操作,反之每个插入操作都要等待删除操作,其<strong>内部容量为0</strong></li>
<li>PriorityBlockingQueue 是<strong>无边界</strong>的优先队列,严格意义上讲,大小还是受系统资源影响.</li>
<li>DelayedQueue 和 LinkedTransferQueue 同样是<strong>无边界</strong>的队列.对于无边界的队列,有一个自然的结果,就是 put 操作永远也不会发生其他 BlockingQueue 的那种<strong>等待</strong>情况</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">ankuo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/09/18/【面试】Java并发多线程整理/">http://yoursite.com/2019/09/18/【面试】Java并发多线程整理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/面试/">面试    </a><a class="post-meta__tags" href="/tags/并发/">并发    </a></div><div class="post_share"><div class="social-share" data-image="https://s2.ax1x.com/2019/09/18/nHxqjU.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2017/09/16/【面试】接口抽象类和设计模式整理/"><img class="next_cover lozad" data-src="https://s2.ax1x.com/2019/09/18/nHxbcT.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>【面试】接口抽象类和设计模式整理</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2017/09/07/【面试】Exception和Error/" title="【面试】Exception和Error"><img class="relatedPosts_cover lozad" data-src="https://s2.ax1x.com/2019/09/18/nHxjHJ.jpg"><div class="relatedPosts_title">【面试】Exception和Error</div></a></div><div class="relatedPosts_item"><a href="/2017/09/08/【面试】常见基础面试题整理/" title="【面试】常见基础面试题整理"><img class="relatedPosts_cover lozad" data-src="https://s2.ax1x.com/2019/09/18/nHxINn.jpg"><div class="relatedPosts_title">【面试】常见基础面试题整理</div></a></div><div class="relatedPosts_item"><a href="/2017/09/15/【面试】IO框架面试题整理/" title="【面试】IO框架面试题整理"><img class="relatedPosts_cover lozad" data-src="https://s2.ax1x.com/2019/09/18/nHx5As.png"><div class="relatedPosts_title">【面试】IO框架面试题整理</div></a></div><div class="relatedPosts_item"><a href="/2017/09/16/【面试】接口抽象类和设计模式整理/" title="【面试】接口抽象类和设计模式整理"><img class="relatedPosts_cover lozad" data-src="https://s2.ax1x.com/2019/09/18/nHxbcT.jpg"><div class="relatedPosts_title">【面试】接口抽象类和设计模式整理</div></a></div><div class="relatedPosts_item"><a href="/2017/09/08/【面试】集合面试题整理/" title="【面试】集合面试题整理"><img class="relatedPosts_cover lozad" data-src="https://s2.ax1x.com/2019/09/18/nHxh7j.jpg"><div class="relatedPosts_title">【面试】集合面试题整理</div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://yoursite.com/2019/09/18/【面试】Java并发多线程整理/';
  this.page.identifier = '2019/09/18/【面试】Java并发多线程整理/';
  this.page.title = '【面试】Java并发多线程整理';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;1927 - 2019 By ankuo</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://ankuo.github.io">blog</a>!</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><a id="to_comment" href="#post-comment"><i class="scroll_to_comment fa fa-comments"></i></a><i class="fa fa-book" id="readmode" title="Read Mode"> </i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><i class="fa fa-moon-o nightshift" id="nightshift" title="Dark Mode"></i></section><div id="post_bottom"><div id="post_bottom_items"><a id="mobile_to_comment" href="#post-comment"><i class="mobile_scroll_to_comment fa fa-comments"></i></a><i class="fa fa-list" id="mobile_toc"></i><div id="toc_mobile"><div class="toc_mobile_headline">Catalog</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#synchronized和ReentrantLock有什么区别"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">synchronized和ReentrantLock有什么区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#synchronized底层是如何实现的-什么是锁的降级和升级"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">synchronized底层是如何实现的,什么是锁的降级和升级</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#其他锁"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">其他锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#为什么需要有读写锁-ReadWriteLock"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">为什么需要有读写锁(ReadWriteLock)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#自旋锁"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">自旋锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一个线程两次调用-start-会怎么样"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">一个线程两次调用 start()会怎么样</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#线程的基本概念"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">线程的基本概念</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#死锁"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">死锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Java并发包提供了那些并发工具类"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">Java并发包提供了那些并发工具类</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#CountDownLatch"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text">CountDownLatch</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#CyclicBarrier"><span class="toc_mobile_items-number">9.2.</span> <span class="toc_mobile_items-text">CyclicBarrier</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Semaphore"><span class="toc_mobile_items-number">9.3.</span> <span class="toc_mobile_items-text">Semaphore</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#总结"><span class="toc_mobile_items-number">9.4.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#并发包里提供的线程安全Map、List和Set"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">并发包里提供的线程安全Map、List和Set</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别?</span></a></li></ol></div></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zindex="-1" data-click="false"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPoss":0.5,"vHeadPos":0.5,"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"superSample":2,"width":200,"height":420,"position":"left","hOffset":0,"vOffset":-20},"log":false});</script></body></html>